https://www.cnblogs.com/gonjan-blog/p/6685611.html  代理模式

1.创建一个与代理对象相关联的InvocationHandler

2.创建一个代理对象，代理对象的每个执行方法都会替换执行Invocation中的invoke方法

代理类并不是真正实现服务，而是通过调用委托类（被代理的类）的对象的方法来实现服务


CGLib和JDK动态代理对比
（1） JDK动态代理实现了被代理对象的接口， CGLib代理继承了被代理对象。
（2） JDK动态代理和CGLib代理都在运行期生成字节码，
JDK动态代理直接写Class字节码，
CGLib代理使用ASM框架写Class字节码，
CGlib代理实现更复杂，生成代理类比JDK动态代理效率低。

（ 3） JDK动态代理调用代理方法是通过反射机制调用的，
CGLib代理是通过FastClass机制直接调用方法的， CGLib代理的执行效率更高。


2.Spring中的代理选择原则
（ 1）当Bean有实现接口时， Spring就会用JDK动态代理。
（ 2）当Bean没有实现接口时， Spring会选择CGLib代理。

1、CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；
2、但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距；
3、因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反正，则比较适用JDK动态代理。


在1.6和1.7的时候，JDK动态代理的速度要比CGLib动态代理的速度要慢，但是并没有教科书上的10倍差距，
在JDK1.8的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了，希望小伙伴在遇到这个问题的时候能够有的放矢！